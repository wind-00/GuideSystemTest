# Orchestrator 模块实现计划

## 1. 模块结构

按照要求创建以下目录结构：

```
orchestrator/
  ├─ overlay/        // 悬浮窗 UI
  ├─ state/          // 页面状态采集
  ├─ planner/        // Planner 接口
  ├─ executor/       // Executor 接口
  ├─ control/        // 主流程控制器
  └─ model/          // 数据结构
```

## 2. 核心功能实现

### 2.1 数据结构（model/）
- `OrchestratorStatus.kt`：定义执行状态枚举
- `UserRequest.kt`：定义用户请求数据类
- `PlanningResult.kt`：定义规划结果密封类

### 2.2 状态采集（state/）
- `RuntimeStateProvider.kt`：定义运行时状态提供者接口
- `RuntimeStateProviderImpl.kt`：实现运行时状态提供者，内部复用 Executor 的 PageStateProvider

### 2.3 Planner 接口（planner/）
- `PlannerClient.kt`：定义 Planner 客户端接口，用于调用 Planner 进行路径规划

### 2.4 Executor 接口（executor/）
- `ExecutorClient.kt`：定义 Executor 客户端接口，用于调用 Executor 执行动作路径

### 2.5 悬浮窗 UI（overlay/）
- `OverlayService.kt`：实现悬浮窗服务，使用 SYSTEM_ALERT_WINDOW / TYPE_APPLICATION_OVERLAY
- `OverlayView.kt`：实现悬浮窗视图，包含当前 pageId 显示、用户输入框、执行按钮和状态展示

### 2.6 主流程控制器（control/）
- `Orchestrator.kt`：实现 Orchestrator 主类，协调各个模块的调用
- `OrchestratorImpl.kt`：实现 Orchestrator 接口，包含完整的控制流程

## 3. 主控制流程

按照要求实现以下控制流程：

```kotlin
onUserClickExecute() {
    val page = stateProvider.getCurrentPageId()
    val request = UserRequest(inputText, page)

    status = PLANNING
    val plan = planner.plan(request)

    if (plan is Failed) {
        status = FAILED
        return
    }

    status = EXECUTING
    for (step in plan.actionPath.steps) {
        val currentPage = stateProvider.getCurrentPageId()
        val result = executor.execute(step, currentPage)

        if (result is Failed) {
            status = FAILED
            return
        }
    }

    status = COMPLETED
}
```

## 4. 关键技术点

1. **悬浮窗实现**：使用 Android 的 SYSTEM_ALERT_WINDOW 权限和 TYPE_APPLICATION_OVERLAY 类型，确保悬浮窗永远浮在 App UI 之上，不属于 Activity / Fragment 层级。

2. **状态采集**：实现 RuntimeStateProvider 接口，内部复用 Executor 的 PageStateProvider，但不直接耦合其实现。

3. **模块解耦**：通过接口与 Executor 和 Planner 进行交互，确保可随时替换实现。

4. **执行协调**：严格按照要求的顺序执行每个动作步骤，每步执行前重新获取当前页面 ID 并传给 Executor。

5. **执行监控**：实现执行过程的状态监控和中断控制，支持手动停止执行。

## 5. 集成与测试

1. **模块集成**：将 Orchestrator 模块集成到主应用中，确保与 Executor 和 Planner 模块正确交互。

2. **功能测试**：测试悬浮窗的显示和交互、状态采集的准确性、Planner 的调用、Executor 的执行协调以及执行过程的监控和中断控制。

3. **边界测试**：测试 Planner 或 Executor 不可用的情况，确保悬浮窗仍能正常运行。

## 6. 注意事项

1. **权限处理**：确保在 AndroidManifest.xml 中添加 SYSTEM_ALERT_WINDOW 权限，并在运行时请求用户授权。

2. **线程处理**：所有 UI 操作在主线程执行，耗时操作（如 Planner 规划和 Executor 执行）在后台线程执行。

3. **内存管理**：确保悬浮窗在不需要时正确销毁，避免内存泄漏。

4. **错误处理**：对所有可能的错误情况进行处理，确保模块的稳定性和可靠性。

5. **代码风格**：遵循 Kotlin 代码风格规范，保持代码清晰、简洁、可维护。